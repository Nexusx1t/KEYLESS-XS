local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
 -- PRINCIAL

local Window = Rayfield:CreateWindow({
   Name = "KEYLESS | X",
   LoadingTitle = "BETA VERCION",
   LoadingSubtitle = "By | NEXUS",
   ConfigurationSaving = {
      Enabled = false,
      FolderName = nil, 
      FileName = "lol"
   },
   Discord = {
      Enabled = false,
      Invite = "noinvitelink",
      RememberJoins = true 
   },
   KeySystem = false, 
   KeySettings = {
      Title = "Key",
      Subtitle = "Key System",
      Note = "Key In Discord Server",
      FileName = "YoutubeHubKey1", 
      SaveKey = false, 
      GrabKeyFromSite = true, 
      Key = {"https://pastebin.com/raw/AtgzSPWK"} 
   }
})

local MainTab = Window:CreateTab("Main | üè†", nil)
local MainSection = MainTab:CreateSection("Main")

-- NOTIFICACION

Rayfield:Notify({
   Title = "Discord",
   Content = "Reporta bugs, en el discord",
   Duration = 5,
   Image = 13047715178,
   Actions = { -- Notification boton
      Ignore = {
         Name = "Okay!",
         Callback = function()
         print("The user tapped Okay!")
      end
   },
},
})

local Button = MainTab:CreateButton({
   Name = "Infinite Jump",
   Callback = function()
       --Toggles the infinite jump between on or off on every script run
_G.infinjump = not _G.infinjump

if _G.infinJumpStarted == nil then
	--Ensures this only runs once to save resources
	_G.infinJumpStarted = true
	
	
	
	--The actual infinite jump
	local plr = game:GetService('Players').LocalPlayer
	local m = plr:GetMouse()
	m.KeyDown:connect(function(k)
		if _G.infinjump then
			if k:byte() == 32 then
			humanoid = game:GetService'Players'.LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
			humanoid:ChangeState('Jumping')
			wait()
			humanoid:ChangeState('Seated')
			end
		end
	end)
end
   end,
})

local Slider = MainTab:CreateSlider({
   Name = "WalkSpeed Slider",
   Range = {1, 350},
   Increment = 1,
   Suffix = "Speed",
   CurrentValue = 16,
   Flag = "sliderws", 
   Callback = function(Value)
        game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = (Value)
   end,
})

local Slider = MainTab:CreateSlider({
   Name = "JumpPower Slider",
   Range = {1, 350},
   Increment = 1,
   Suffix = "Speed",
   CurrentValue = 16,
   Flag = "sliderjp", 
   Callback = function(Value)
        game.Players.LocalPlayer.Character.Humanoid.JumpPower = (Value)
   end,
})

local ColorPicker = MainTab:CreateColorPicker({
    Name = "Set Color",
    Color = Color3.fromRGB(255,255,255),
    Flag = "ColorPicker1", 
    Callback = function(Value)
        
    end
})
local ClassicTab = Window:CreateTab("Visual | üëÄ", nil)
local Section = ClassicTab:CreateSection("Visual | Hack")

local Button = MainTab:CreateButton({
    Name = "Superman Mode",
    Callback = function()
        local FlyScript = Instance.new("ScreenGui")
        local Gradient = Instance.new("Frame")
        local UIGradient = Instance.new("UIGradient")
        local UICorner = Instance.new("UICorner")
        local Button = Instance.new("TextButton")
        local Shadow = Instance.new("Frame")
        local TextLabel = Instance.new("TextLabel")
        
        --Properties:
        
        FlyScript.Name = "FlyScript"
        FlyScript.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
        FlyScript.ResetOnSpawn = false
        
        Gradient.Name = "Gradient"
        Gradient.Parent = FlyScript
        Gradient.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        Gradient.BorderColor3 = Color3.fromRGB(27, 42, 53)
        Gradient.BorderSizePixel = 0
        Gradient.Position = UDim2.new(0.0199062824, 0, 0.781767964, 0)
        Gradient.Size = UDim2.new(0, 231, 0, 81)
        
        UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(57, 104, 252)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(51, 68, 175))}
        UIGradient.Parent = Gradient
        
        UICorner.CornerRadius = UDim.new(0.0399999991, 0)
        UICorner.Parent = Gradient
        
        Button.Name = "Button"
        Button.Parent = Gradient
        Button.BackgroundColor3 = Color3.fromRGB(77, 100, 150)
        Button.BorderSizePixel = 0
        Button.Position = UDim2.new(0.0921155736, 0, 0.238353431, 0)
        Button.Size = UDim2.new(0, 187, 0, 41)
        Button.ZIndex = 2
        Button.Font = Enum.Font.GothamSemibold
        Button.Text = ""
        Button.TextColor3 = Color3.fromRGB(255, 255, 255)
        Button.TextScaled = true
        Button.TextSize = 14.000
        Button.TextWrapped = true
        
        Shadow.Name = "Shadow"
        Shadow.Parent = Button
        Shadow.BackgroundColor3 = Color3.fromRGB(53, 69, 103)
        Shadow.BorderSizePixel = 0
        Shadow.Size = UDim2.new(1, 0, 1, 4)
        
        TextLabel.Parent = Gradient
        TextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
        TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        TextLabel.BackgroundTransparency = 1.000
        TextLabel.BorderColor3 = Color3.fromRGB(27, 42, 53)
        TextLabel.BorderSizePixel = 0
        TextLabel.Position = UDim2.new(0.487012982, 0, 0.5, 0)
        TextLabel.Size = UDim2.new(0.878787875, -20, 0.728395045, -20)
        TextLabel.ZIndex = 2
        TextLabel.Font = Enum.Font.GothamBold
        TextLabel.Text = "Fly"
        TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        TextLabel.TextScaled = true
        TextLabel.TextSize = 14.000
        TextLabel.TextWrapped = true
        Button.MouseButton1Down:connect(function()
            repeat wait()
            until game.Players.LocalPlayer and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:findFirstChild("Torso") and game.Players.LocalPlayer.Character:findFirstChild("Humanoid")
            local mouse = game.Players.LocalPlayer:GetMouse()
            repeat wait() until mouse
            local plr = game.Players.LocalPlayer
            local torso = plr.Character.Torso
            local flying = true
            local deb = true
            local ctrl = {f = 0, b = 0, l = 0, r = 0}
            local lastctrl = {f = 0, b = 0, l = 0, r = 0}
            local maxspeed = 50
            local speed = 0
        
            function Fly()
                local bg = Instance.new("BodyGyro", torso)
                bg.P = 9e4
                bg.maxTorque = Vector3.new(9e9, 9e9, 9e9)
                bg.cframe = torso.CFrame
                local bv = Instance.new("BodyVelocity", torso)
                bv.velocity = Vector3.new(0,0.1,0)
                bv.maxForce = Vector3.new(9e9, 9e9, 9e9)
                repeat wait()
                    plr.Character.Humanoid.PlatformStand = true
                    if ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0 then
                        speed = speed+.5+(speed/maxspeed)
                        if speed > maxspeed then
                            speed = maxspeed
                        end
                    elseif not (ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0) and speed ~= 0 then
                        speed = speed-1
                        if speed < 0 then
                            speed = 0
                        end
                    end
                    if (ctrl.l + ctrl.r) ~= 0 or (ctrl.f + ctrl.b) ~= 0 then
                        bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (ctrl.f+ctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(ctrl.l+ctrl.r,(ctrl.f+ctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
                        lastctrl = {f = ctrl.f, b = ctrl.b, l = ctrl.l, r = ctrl.r}
                    elseif (ctrl.l + ctrl.r) == 0 and (ctrl.f + ctrl.b) == 0 and speed ~= 0 then
                        bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (lastctrl.f+lastctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(lastctrl.l+lastctrl.r,(lastctrl.f+lastctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
                    else
                        bv.velocity = Vector3.new(0,0.1,0)
                    end
                    bg.cframe = game.Workspace.CurrentCamera.CoordinateFrame * CFrame.Angles(-math.rad((ctrl.f+ctrl.b)*50*speed/maxspeed),0,0)
                until not flying
                ctrl = {f = 0, b = 0, l = 0, r = 0}
                lastctrl = {f = 0, b = 0, l = 0, r = 0}
                speed = 0
                bg:Destroy()
                bv:Destroy()
                plr.Character.Humanoid.PlatformStand = false
            end
            mouse.KeyDown:connect(function(key)
                if key:lower() == "e" then
                    if flying then flying = false
                    else
                        flying = true
                        Fly()
                    end
                elseif key:lower() == "w" then
                    ctrl.f = 1
                elseif key:lower() == "s" then
                    ctrl.b = -1
                elseif key:lower() == "a" then
                    ctrl.l = -1
                elseif key:lower() == "d" then
                    ctrl.r = 1
                end
            end)
            mouse.KeyUp:connect(function(key)
                if key:lower() == "w" then
                    ctrl.f = 0
                elseif key:lower() == "s" then
                    ctrl.b = 0
                elseif key:lower() == "a" then
                    ctrl.l = 0
                elseif key:lower() == "d" then
                    ctrl.r = 0
                end
            end)
            Fly()
        
        end)
        -- Scripts:
        
        local function LHMZZV_fake_script() -- FlyScript.Script 
            local script = Instance.new('Script', FlyScript)
        
            frame = script.Parent.Gradient -- Take out {}s, and put name of frame
            frame.Draggable = true
            frame.Active = true
            frame.Selectable = true
        end
        coroutine.wrap(LHMZZV_fake_script)()
    end,
 })

 local Label = ClassicTab:CreateLabel("Universal | ESP")
 local Button = ClassicTab:CreateButton({
    Name = "WALLHACK - RED",
    Callback = function()
        player = game:GetService("Players").LocalPlayer or owner;
        repeat wait() until  player.Character ~=nil;
        player.Character:WaitForChild("Humanoid");
        game:GetService("Workspace").Camera:ClearAllChildren();
        
        
        game:GetService("RunService").RenderStepped:connect(function()
        for k,v in pairs(game:GetService("Workspace").Camera:GetChildren()) do	
        for a,b in pairs(v:GetChildren()) do
        if b.ClassName == "Part" then
        pcall(function()
        b.CFrame = game:GetService("Workspace"):FindFirstChild(v.Name):FindFirstChild(b.Name).CFrame;
        end);
        end;
        end;
        end;
        end);
        
        coroutine.wrap(function()
        while wait() do
        for k,v in pairs(game:GetService("Workspace"):GetChildren()) do
        if v:FindFirstChild("Humanoid") ~=nil and v ~= player.Character then
        if game:GetService("Workspace").Camera:FindFirstChild(v.Name) ==nil then
        v.Archivable = true;
        local player = v:Clone();
        for k,v in pairs(player:GetChildren()) do
        if v.ClassName == "Part" then
        v.Locked = true;
        v.Anchored = true;
        v.CanCollide = false;
        v.Transparency = 1;
        v.BrickColor = BrickColor.new("Bright red");
        local billboardgui = Instance.new("BillboardGui", v);
        billboardgui.Size = UDim2.new(1,0,1,0);
        billboardgui.AlwaysOnTop = true;
        local frame = Instance.new("Frame", billboardgui);
        frame.BorderSizePixel = 0;
        frame.BackgroundColor3 = Color3.new(255/255,0/255,0/255);
        frame.BackgroundTransparency = .5;
        if v.Name == "Head" then
        frame.Size = UDim2.new(1,0,1,0);
        elseif v.Name == "Torso" then
        frame.Size = UDim2.new(2,0,2,0);
        frame.Position = UDim2.new(-.5,0,-.5,0);
        elseif v.Name == "Left Arm" or v.Name == "Right Arm" or v.Name == "Left Leg" or v.Name == "Right Leg" then
        frame.Size = UDim2.new(1,0,2,0);
        frame.Position = UDim2.new(0,0,-.5,0)	;
        end;
        elseif v.ClassName ~= "Part" then
        v:remove();	
        end	;
        end;
        player.Parent = game:GetService("Workspace").Camera;
        v.Archivable = false;	
        end;
        end	;
        end;
        
        if player.Character.Humanoid.Health == 0 then
        game:GetService("Workspace").Camera:ClearAllChildren();
        break;
        end;
        end;
        end)();
    end,
 })

 local Button = ClassicTab:CreateButton({
    Name = "BOX + HEALTH - ESP",
    Callback = function()
        local Settings = {
            Box_Color = Color3.fromRGB(255, 0, 0),
            Tracer_Color = Color3.fromRGB(255, 0, 0),
            Tracer_Thickness = 1,
            Box_Thickness = 1,
            Tracer_Origin = "Bottom", -- Middle or Bottom if FollowMouse is on this won't matter...
            Tracer_FollowMouse = false,
            Tracers = true
        }
        local Team_Check = {
            TeamCheck = false, -- if TeamColor is on this won't matter...
            Green = Color3.fromRGB(0, 255, 0),
            Red = Color3.fromRGB(255, 0, 0)
        }
        local TeamColor = true
        
        --// SEPARATION
        local player = game:GetService("Players").LocalPlayer
        local camera = game:GetService("Workspace").CurrentCamera
        local mouse = player:GetMouse()
        
        local function NewQuad(thickness, color)
            local quad = Drawing.new("Quad")
            quad.Visible = false
            quad.PointA = Vector2.new(0,0)
            quad.PointB = Vector2.new(0,0)
            quad.PointC = Vector2.new(0,0)
            quad.PointD = Vector2.new(0,0)
            quad.Color = color
            quad.Filled = false
            quad.Thickness = thickness
            quad.Transparency = 1
            return quad
        end
        
        local function NewLine(thickness, color)
            local line = Drawing.new("Line")
            line.Visible = false
            line.From = Vector2.new(0, 0)
            line.To = Vector2.new(0, 0)
            line.Color = color 
            line.Thickness = thickness
            line.Transparency = 1
            return line
        end
        
        local function Visibility(state, lib)
            for u, x in pairs(lib) do
                x.Visible = state
            end
        end
        
        local function ToColor3(col) --Function to convert, just cuz c;
            local r = col.r --Red value
            local g = col.g --Green value
            local b = col.b --Blue value
            return Color3.new(r,g,b); --Color3 datatype, made of the RGB inputs
        end
        
        local black = Color3.fromRGB(0, 0 ,0)
        local function ESP(plr)
            local library = {
                --//Tracer and Black Tracer(black border)
                blacktracer = NewLine(Settings.Tracer_Thickness*2, black),
                tracer = NewLine(Settings.Tracer_Thickness, Settings.Tracer_Color),
                --//Box and Black Box(black border)
                black = NewQuad(Settings.Box_Thickness*2, black),
                box = NewQuad(Settings.Box_Thickness, Settings.Box_Color),
                --//Bar and Green Health Bar (part that moves up/down)
                healthbar = NewLine(3, black),
                greenhealth = NewLine(1.5, black)
            }
        
            local function Colorize(color)
                for u, x in pairs(library) do
                    if x ~= library.healthbar and x ~= library.greenhealth and x ~= library.blacktracer and x ~= library.black then
                        x.Color = color
                    end
                end
            end
        
            local function Updater()
                local connection
                connection = game:GetService("RunService").RenderStepped:Connect(function()
                    if plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("Head") ~= nil then
                        local HumPos, OnScreen = camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                        if OnScreen then
                            local head = camera:WorldToViewportPoint(plr.Character.Head.Position)
                            local DistanceY = math.clamp((Vector2.new(head.X, head.Y) - Vector2.new(HumPos.X, HumPos.Y)).magnitude, 2, math.huge)
                            
                            local function Size(item)
                                item.PointA = Vector2.new(HumPos.X + DistanceY, HumPos.Y - DistanceY*2)
                                item.PointB = Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2)
                                item.PointC = Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)
                                item.PointD = Vector2.new(HumPos.X + DistanceY, HumPos.Y + DistanceY*2)
                            end
                            Size(library.box)
                            Size(library.black)
        
                            --//Tracer 
                            if Settings.Tracers then
                                if Settings.Tracer_Origin == "Middle" then
                                    library.tracer.From = camera.ViewportSize*0.5
                                    library.blacktracer.From = camera.ViewportSize*0.5
                                elseif Settings.Tracer_Origin == "Bottom" then
                                    library.tracer.From = Vector2.new(camera.ViewportSize.X*0.5, camera.ViewportSize.Y) 
                                    library.blacktracer.From = Vector2.new(camera.ViewportSize.X*0.5, camera.ViewportSize.Y)
                                end
                                if Settings.Tracer_FollowMouse then
                                    library.tracer.From = Vector2.new(mouse.X, mouse.Y+36)
                                    library.blacktracer.From = Vector2.new(mouse.X, mouse.Y+36)
                                end
                                library.tracer.To = Vector2.new(HumPos.X, HumPos.Y + DistanceY*2)
                                library.blacktracer.To = Vector2.new(HumPos.X, HumPos.Y + DistanceY*2)
                            else 
                                library.tracer.From = Vector2.new(0, 0)
                                library.blacktracer.From = Vector2.new(0, 0)
                                library.tracer.To = Vector2.new(0, 0)
                                library.blacktracer.To = Vector2.new(0, 02)
                            end
        
                            --// Health Bar
                            local d = (Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2) - Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)).magnitude 
                            local healthoffset = plr.Character.Humanoid.Health/plr.Character.Humanoid.MaxHealth * d
        
                            library.greenhealth.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                            library.greenhealth.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2 - healthoffset)
        
                            library.healthbar.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                            library.healthbar.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y - DistanceY*2)
        
                            local green = Color3.fromRGB(0, 255, 0)
                            local red = Color3.fromRGB(255, 0, 0)
        
                            library.greenhealth.Color = red:lerp(green, plr.Character.Humanoid.Health/plr.Character.Humanoid.MaxHealth);
        
                            if Team_Check.TeamCheck then
                                if plr.TeamColor == player.TeamColor then
                                    Colorize(Team_Check.Green)
                                else 
                                    Colorize(Team_Check.Red)
                                end
                            else 
                                library.tracer.Color = Settings.Tracer_Color
                                library.box.Color = Settings.Box_Color
                            end
                            if TeamColor == true then
                                Colorize(plr.TeamColor.Color)
                            end
                            Visibility(true, library)
                        else 
                            Visibility(false, library)
                        end
                    else 
                        Visibility(false, library)
                        if game.Players:FindFirstChild(plr.Name) == nil then
                            connection:Disconnect()
                        end
                    end
                end)
            end
            coroutine.wrap(Updater)()
        end
        
        for i, v in pairs(game:GetService("Players"):GetPlayers()) do
            if v.Name ~= player.Name then
                coroutine.wrap(ESP)(v)
            end
        end
        
        game.Players.PlayerAdded:Connect(function(newplr)
            if newplr.Name ~= player.Name then
                coroutine.wrap(ESP)(newplr)
            end
        end)
    end,
 })

 local Button = ClassicTab:CreateButton({
    Name = "Draw Chams",
    Callback = function()
        local Settings = {
            TeamCheck = true, -- Overules Color
            Red = Color3.fromRGB(255, 0, 0),
            Green = Color3.fromRGB(0, 255, 0),
            Color = Color3.fromRGB(255, 0, 0),
            TeamColor = false
        }
        
        --// Locals
        local player = game:GetService("Players").LocalPlayer
        local camera = game:GetService("Workspace").CurrentCamera
        local mouse = player:GetMouse()
        
        local function NewQuad(color)
            local quad = Drawing.new("Quad")
            quad.Visible = false
            quad.PointA = Vector2.new(0,0)
            quad.PointB = Vector2.new(0,0)
            quad.PointC = Vector2.new(0,0)
            quad.PointD = Vector2.new(0,0)
            quad.Color = color
            quad.Filled = true
            quad.Thickness = 1
            quad.Transparency = 0.25
            return quad
        end
        
        local function Colorize(color, lib)
            for i, v in pairs(lib) do
                v.Color = color
            end
        end
        
        local function ESP(object, plr)
            local part = object
            --// Quads for 3D box (6)
            local quads = {
                quad1 = NewQuad(Settings.Color),
                quad2 = NewQuad(Settings.Color),
                quad3 = NewQuad(Settings.Color),
                quad4 = NewQuad(Settings.Color),
                quad5 = NewQuad(Settings.Color),
                quad6 = NewQuad(Settings.Color)
            }
        
            --// Updates ESP in render loop
            local function Updater()
                local connection
                connection = game:GetService("RunService").RenderStepped:Connect(function()
                    if plr.Character ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild(object.Name) ~= nil then
                            local partpos, onscreen = camera:WorldToViewportPoint(part.Position)
                            if onscreen then
                                local size_X = part.Size.X/2
                                local size_Y = part.Size.Y/2
                                local size_Z = part.Size.Z/2
                                
                                local Top1 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(-size_X, size_Y, -size_Z)).p)
                                local Top2 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(-size_X, size_Y, size_Z)).p)
                                local Top3 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(size_X, size_Y, size_Z)).p)
                                local Top4 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(size_X, size_Y, -size_Z)).p)
            
                                local Bottom1 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(-size_X, -size_Y, -size_Z)).p)
                                local Bottom2 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(-size_X, -size_Y, size_Z)).p)
                                local Bottom3 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(size_X, -size_Y, size_Z)).p)
                                local Bottom4 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(size_X, -size_Y, -size_Z)).p)
            
                                --// Top:
                                quads.quad1.PointA = Vector2.new(Top1.X, Top1.Y)
                                quads.quad1.PointB = Vector2.new(Top2.X, Top2.Y)
                                quads.quad1.PointC = Vector2.new(Top3.X, Top3.Y)
                                quads.quad1.PointD = Vector2.new(Top4.X, Top4.Y)
            
                                --//Bottom:
                                quads.quad2.PointA = Vector2.new(Bottom1.X, Bottom1.Y)
                                quads.quad2.PointB = Vector2.new(Bottom2.X, Bottom2.Y)
                                quads.quad2.PointC = Vector2.new(Bottom3.X, Bottom3.Y)
                                quads.quad2.PointD = Vector2.new(Bottom4.X, Bottom4.Y)
            
                                --//Sides:
                                quads.quad3.PointA = Vector2.new(Top1.X, Top1.Y)
                                quads.quad3.PointB = Vector2.new(Top2.X, Top2.Y)
                                quads.quad3.PointC = Vector2.new(Bottom2.X, Bottom2.Y)
                                quads.quad3.PointD = Vector2.new(Bottom1.X, Bottom1.Y)
                                
                                quads.quad4.PointA = Vector2.new(Top2.X, Top2.Y)
                                quads.quad4.PointB = Vector2.new(Top3.X, Top3.Y)
                                quads.quad4.PointC = Vector2.new(Bottom3.X, Bottom3.Y)
                                quads.quad4.PointD = Vector2.new(Bottom2.X, Bottom2.Y)
                                
                                quads.quad5.PointA = Vector2.new(Top3.X, Top3.Y)
                                quads.quad5.PointB = Vector2.new(Top4.X, Top4.Y)
                                quads.quad5.PointC = Vector2.new(Bottom4.X, Bottom4.Y)
                                quads.quad5.PointD = Vector2.new(Bottom3.X, Bottom3.Y)
            
                                quads.quad6.PointA = Vector2.new(Top4.X, Top4.Y)
                                quads.quad6.PointB = Vector2.new(Top1.X, Top1.Y)
                                quads.quad6.PointC = Vector2.new(Bottom1.X, Bottom1.Y)
                                quads.quad6.PointD = Vector2.new(Bottom4.X, Bottom4.Y)
            
                                if Settings.Team_Check then
                                    if plr.TeamColor == player.TeamColor then
                                        local group_color = Settings.Green
                                        Colorize(group_color, quads)
                                    else 
                                        local group_color = Settings.Red
                                        Colorize(group_color, quads)
                                    end
                                else 
                                    local group_color = Settings.Color
                                    Colorize(group_color, quads)
                                end
        
                                if Settings.TeamColor then
                                    Colorize(plr.TeamColor.Color, quads)
                                end
            
                                for u, x in pairs(quads) do
                                    x.Visible = true
                                end
                            else 
                                for u, x in pairs(quads) do
                                    x.Visible = false
                                end
                            end
                    else 
                        for u, x in pairs(quads) do
                            x.Visible = false
                        end
                        if game.Players:FindFirstChild(plr.Name) == nil then
                            connection:Disconnect()
                        end
                    end
                end)
            end
            coroutine.wrap(Updater)()
        end
        
        for i, v in pairs(game:GetService("Players"):GetPlayers()) do
            spawn(function()
                if v.Name ~= player.Name then
                    repeat wait() until v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v.Character.Humanoid.Health > 0 and v.Character:FindFirstChild("Head") ~= nil
                    for u, x in pairs(v.Character:GetChildren()) do
                        if x:IsA("MeshPart") or x.Name == "Head" or x.Name == "Left Arm" or x.Name == "Right Arm" or x.Name == "Right Leg" or x.Name == "Left Leg" or x.Name == "Torso" then
                            coroutine.wrap(ESP)(x, v)
                        end
                    end
                end
            end)
        end
        
        game.Players.PlayerAdded:Connect(function(newplr)
            spawn(function()
                if newplr.Name ~= player.Name then
                    repeat wait() until newplr.Character ~= nil and newplr.Character:FindFirstChild("Humanoid") ~= nil and newplr.Character:FindFirstChild("HumanoidRootPart") ~= nil and newplr.Character.Humanoid.Health > 0 and newplr.Character:FindFirstChild("Head") ~= nil
                    for u, x in pairs(newplr.Character:GetChildren()) do
                        if x:IsA("MeshPart") or x.Name == "Head" or x.Name == "Left Arm" or x.Name == "Right Arm" or x.Name == "Right Leg" or x.Name == "Left Leg" or x.Name == "Torso" then
                            coroutine.wrap(ESP)(x, newplr)
                        end
                    end
                end
            end)
        end)
    end,
 })

 local Button = MainTab:CreateButton({
    Name = "Kill GUI",
    Callback = function()
        local KillGui = Instance.new("ScreenGui")
        local Opener = Instance.new("TextButton")
        local UIGradient = Instance.new("UIGradient")
        local Frame = Instance.new("ImageLabel")
        local Player = Instance.new("TextBox")
        local UIGradient_2 = Instance.new("UIGradient")
        local Kill = Instance.new("TextButton")
        local Cancel = Instance.new("TextButton")
        local LKill = Instance.new("TextButton")
        local UIGradient_3 = Instance.new("UIGradient")
        
        --Properties:
        
        KillGui.Name = "KillGui"
        KillGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
        KillGui.ResetOnSpawn = false
        
        Opener.Name = "Opener"
        Opener.Parent = KillGui
        Opener.BackgroundColor3 = Color3.fromRGB(80, 255, 116)
        Opener.BackgroundTransparency = 1.000
        Opener.BorderSizePixel = 0
        Opener.Position = UDim2.new(0.890184641, 0, 0.665688097, 0)
        Opener.Size = UDim2.new(0, 113, 0, 50)
        Opener.ZIndex = 2
        Opener.Font = Enum.Font.SourceSans
        Opener.Text = "Open"
        Opener.TextColor3 = Color3.fromRGB(255, 255, 255)
        Opener.TextScaled = true
        Opener.TextSize = 14.000
        Opener.TextWrapped = true
        
        UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 0, 0)), ColorSequenceKeypoint.new(0.23, Color3.fromRGB(238, 0, 255)), ColorSequenceKeypoint.new(0.48, Color3.fromRGB(0, 0, 255)), ColorSequenceKeypoint.new(0.63, Color3.fromRGB(32, 244, 255)), ColorSequenceKeypoint.new(0.78, Color3.fromRGB(4, 255, 0)), ColorSequenceKeypoint.new(0.89, Color3.fromRGB(255, 255, 0)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 0, 0))}
        UIGradient.Parent = Opener
        
        Frame.Name = "Frame"
        Frame.Parent = KillGui
        Frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        Frame.BackgroundTransparency = 1.000
        Frame.Position = UDim2.new(0.753321111, 0, 0.741761386, 0)
        Frame.Size = UDim2.new(0, 253, 0, 170)
        Frame.Visible = false
        Frame.Image = "rbxassetid://2851926732"
        Frame.ImageColor3 = Color3.fromRGB(72, 255, 96)
        Frame.ScaleType = Enum.ScaleType.Slice
        Frame.SliceCenter = Rect.new(12, 12, 12, 12)
        
        Player.Name = "Player"
        Player.Parent = Frame
        Player.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        Player.BackgroundTransparency = 0.750
        Player.BorderSizePixel = 0
        Player.Position = UDim2.new(0.0967741907, 0, 0.152100846, 0)
        Player.Size = UDim2.new(0, 200, 0, 50)
        Player.ZIndex = 2
        Player.Font = Enum.Font.FredokaOne
        Player.PlaceholderText = "Player To Kill"
        Player.Text = ""
        Player.TextColor3 = Color3.fromRGB(255, 255, 255)
        Player.TextScaled = true
        Player.TextSize = 14.000
        Player.TextWrapped = true
        
        UIGradient_2.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 0, 0)), ColorSequenceKeypoint.new(0.23, Color3.fromRGB(238, 0, 255)), ColorSequenceKeypoint.new(0.48, Color3.fromRGB(0, 0, 255)), ColorSequenceKeypoint.new(0.63, Color3.fromRGB(32, 244, 255)), ColorSequenceKeypoint.new(0.78, Color3.fromRGB(4, 255, 0)), ColorSequenceKeypoint.new(0.89, Color3.fromRGB(255, 255, 0)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 0, 0))}
        UIGradient_2.Parent = Player
        
        Kill.Name = "Kill"
        Kill.Parent = Frame
        Kill.BackgroundColor3 = Color3.fromRGB(141, 255, 142)
        Kill.BackgroundTransparency = 1.000
        Kill.BorderSizePixel = 0
        Kill.Position = UDim2.new(0, 0, 0.700840294, 0)
        Kill.Size = UDim2.new(0, 73, 0, 50)
        Kill.ZIndex = 2
        Kill.Font = Enum.Font.SourceSans
        Kill.Text = "Kill"
        Kill.TextColor3 = Color3.fromRGB(255, 255, 255)
        Kill.TextScaled = true
        Kill.TextSize = 14.000
        Kill.TextWrapped = true
        
        Cancel.Name = "Cancel"
        Cancel.Parent = Frame
        Cancel.BackgroundColor3 = Color3.fromRGB(141, 255, 142)
        Cancel.BackgroundTransparency = 1.000
        Cancel.BorderSizePixel = 0
        Cancel.Position = UDim2.new(0.705645204, 0, 0.700840294, 0)
        Cancel.Size = UDim2.new(0, 73, 0, 50)
        Cancel.ZIndex = 2
        Cancel.Font = Enum.Font.SourceSans
        Cancel.Text = "Cancel"
        Cancel.TextColor3 = Color3.fromRGB(255, 255, 255)
        Cancel.TextScaled = true
        Cancel.TextSize = 14.000
        Cancel.TextWrapped = true
        
        LKill.Name = "LKill"
        LKill.Parent = Frame
        LKill.BackgroundColor3 = Color3.fromRGB(141, 255, 142)
        LKill.BackgroundTransparency = 1.000
        LKill.BorderSizePixel = 0
        LKill.Position = UDim2.new(0.342741907, 0, 0.700840294, 0)
        LKill.Size = UDim2.new(0, 73, 0, 50)
        LKill.ZIndex = 2
        LKill.Font = Enum.Font.SourceSans
        LKill.Text = "Loopkill"
        LKill.TextColor3 = Color3.fromRGB(255, 255, 255)
        LKill.TextScaled = true
        LKill.TextSize = 14.000
        LKill.TextWrapped = true
        
        UIGradient_3.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 0, 0)), ColorSequenceKeypoint.new(0.23, Color3.fromRGB(238, 0, 255)), ColorSequenceKeypoint.new(0.48, Color3.fromRGB(0, 0, 255)), ColorSequenceKeypoint.new(0.63, Color3.fromRGB(32, 244, 255)), ColorSequenceKeypoint.new(0.78, Color3.fromRGB(4, 255, 0)), ColorSequenceKeypoint.new(0.89, Color3.fromRGB(255, 255, 0)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 0, 0))}
        UIGradient_3.Parent = Frame
        
        -- Scripts:
        
        local function HJEL_fake_script() -- KillGui.LocalScript 
            local script = Instance.new('LocalScript', KillGui)
        
            script.Parent.Opener.MouseButton1Click:Connect(function()
                script.Parent.Frame.Visible = true
            end)
            
            script.Parent.Frame.Cancel.MouseButton1Click:Connect(function()
                script.Parent.Frame.Visible = false
            end)
            
            script.Parent.Frame.Kill.MouseButton1Click:Connect(function()
                game.Players:FindFirstChild(script.Parent.Frame.Player.Text).Character.Humanoid.Health = 0
                script.Parent.Frame.Visible = false
            end)
            
            script.Parent.Frame.LKill.MouseButton1Click:Connect(function()
                while true do
                    game.Players:WaitForChild(script.Parent.Frame.Player.Text).Character.Humanoid.Health = 0
                    wait(1)
                end
                
                script.Parent.Frame.Visible = false
            end)
        end
        coroutine.wrap(HJEL_fake_script)()
    end,
 })


 local UniversalTab = Window:CreateTab("Universal | üåç", nil)
 local Section = UniversalTab:CreateSection("AIM | UNIVERSAL")

 local Button = UniversalTab:CreateButton({
    Name = "Aimbot - Universal",
    Callback = function()
        local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer
local Holding = false

_G.AimbotEnabled = true
_G.TeamCheck = false -- If set to true then the script would only lock your aim at enemy team members.
_G.AimPart = "Head" -- Where the aimbot script would lock at.
_G.Sensitivity = 0 -- How many seconds it takes for the aimbot script to officially lock onto the target's aimpart.

_G.CircleSides = 64 -- How many sides the FOV circle would have.
_G.CircleColor = Color3.fromRGB(255, 255, 255) -- (RGB) Color that the FOV circle would appear as.
_G.CircleTransparency = 0.7 -- Transparency of the circle.
_G.CircleRadius = 80 -- The radius of the circle / FOV.
_G.CircleFilled = false -- Determines whether or not the circle is filled.
_G.CircleVisible = true -- Determines whether or not the circle is visible.
_G.CircleThickness = 0 -- The thickness of the circle.

local FOVCircle = Drawing.new("Circle")
FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
FOVCircle.Radius = _G.CircleRadius
FOVCircle.Filled = _G.CircleFilled
FOVCircle.Color = _G.CircleColor
FOVCircle.Visible = _G.CircleVisible
FOVCircle.Radius = _G.CircleRadius
FOVCircle.Transparency = _G.CircleTransparency
FOVCircle.NumSides = _G.CircleSides
FOVCircle.Thickness = _G.CircleThickness

local function GetClosestPlayer()
	local MaximumDistance = _G.CircleRadius
	local Target = nil

	for _, v in next, Players:GetPlayers() do
		if v.Name ~= LocalPlayer.Name then
			if _G.TeamCheck == true then
				if v.Team ~= LocalPlayer.Team then
					if v.Character ~= nil then
						if v.Character:FindFirstChild("HumanoidRootPart") ~= nil then
							if v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("Humanoid").Health ~= 0 then
								local ScreenPoint = Camera:WorldToScreenPoint(v.Character:WaitForChild("HumanoidRootPart", math.huge).Position)
								local VectorDistance = (Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2.new(ScreenPoint.X, ScreenPoint.Y)).Magnitude
								
								if VectorDistance < MaximumDistance then
									Target = v
								end
							end
						end
					end
				end
			else
				if v.Character ~= nil then
					if v.Character:FindFirstChild("HumanoidRootPart") ~= nil then
						if v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("Humanoid").Health ~= 0 then
							local ScreenPoint = Camera:WorldToScreenPoint(v.Character:WaitForChild("HumanoidRootPart", math.huge).Position)
							local VectorDistance = (Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2.new(ScreenPoint.X, ScreenPoint.Y)).Magnitude
							
							if VectorDistance < MaximumDistance then
								Target = v
							end
						end
					end
				end
			end
		end
	end

	return Target
end

UserInputService.InputBegan:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        Holding = true
    end
end)

UserInputService.InputEnded:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        Holding = false
    end
end)

RunService.RenderStepped:Connect(function()
    FOVCircle.Position = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
    FOVCircle.Radius = _G.CircleRadius
    FOVCircle.Filled = _G.CircleFilled
    FOVCircle.Color = _G.CircleColor
    FOVCircle.Visible = _G.CircleVisible
    FOVCircle.Radius = _G.CircleRadius
    FOVCircle.Transparency = _G.CircleTransparency
    FOVCircle.NumSides = _G.CircleSides
    FOVCircle.Thickness = _G.CircleThickness

    if Holding == true and _G.AimbotEnabled == true then
        TweenService:Create(Camera, TweenInfo.new(_G.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, GetClosestPlayer().Character[_G.AimPart].Position)}):Play()
    end
end)
    end,
 })

 local Button = UniversalTab:CreateButton({
    Name = "Silent Aim | Universal",
    Callback = function()
        local teamCheck = false
        local fov = 90
        local smoothing = 0.02
        local predictionFactor = 0.08  -- Adjust this factor to improve prediction accuracy
        local highlightEnabled = false  -- Variable to enable or disable target highlighting. Change to False if using an ESP script.
        local lockPart = "Head"  -- Choose what part it locks onto. Ex. HumanoidRootPart or Head
         
        local Toggle = false  -- Enable or disable toggle mode
        local ToggleKey = Enum.KeyCode.X  -- Choose the key for toggling aimbot lock
         
        local RunService = game:GetService("RunService")
        local UserInputService = game:GetService("UserInputService")
        local StarterGui = game:GetService("StarterGui")
        local Players = game:GetService("Players")
         
        StarterGui:SetCore("SendNotification", {
            Title = "Silent Aim | Universal";
            Text = " by | Nexus";
            Duration = 4;
        })
         
        local FOVring = Drawing.new("Circle")
        FOVring.Visible = true
        FOVring.Thickness = 1
        FOVring.Radius = fov
        FOVring.Transparency = 0.8
        FOVring.Color = Color3.fromRGB(255, 128, 128)
        FOVring.Position = workspace.CurrentCamera.ViewportSize / 2
         
        local currentTarget = nil
        local aimbotEnabled = true
        local toggleState = false  -- Variable to keep track of toggle state
        local debounce = false  -- Debounce variable
         
        local function getClosest(cframe)
            local ray = Ray.new(cframe.Position, cframe.LookVector).Unit
            local target = nil
            local mag = math.huge
            local screenCenter = workspace.CurrentCamera.ViewportSize / 2
         
            for i, v in pairs(Players:GetPlayers()) do
                if v.Character and v.Character:FindFirstChild(lockPart) and v.Character:FindFirstChild("Humanoid") and v.Character:FindFirstChild("HumanoidRootPart") and v ~= Players.LocalPlayer and (v.Team ~= Players.LocalPlayer.Team or (not teamCheck)) then
                    local screenPoint, onScreen = workspace.CurrentCamera:WorldToViewportPoint(v.Character[lockPart].Position)
                    local distanceFromCenter = (Vector2.new(screenPoint.X, screenPoint.Y) - screenCenter).Magnitude
         
                    if onScreen and distanceFromCenter <= fov then
                        local magBuf = (v.Character[lockPart].Position - ray:ClosestPoint(v.Character[lockPart].Position)).Magnitude
         
                        if magBuf < mag then
                            mag = magBuf
                            target = v
                        end
                    end
                end
            end
         
            return target
        end
         
        local function updateFOVRing()
            FOVring.Position = workspace.CurrentCamera.ViewportSize / 2
        end
         
        local function highlightTarget(target)
            if highlightEnabled and target and target.Character then
                local highlight = Instance.new("Highlight")
                highlight.Adornee = target.Character
                highlight.FillColor = Color3.fromRGB(255, 128, 128)
                highlight.OutlineColor = Color3.fromRGB(255, 0, 0)
                highlight.Parent = target.Character
            end
        end
         
        local function removeHighlight(target)
            if highlightEnabled and target and target.Character and target.Character:FindFirstChildOfClass("Highlight") then
                target.Character:FindFirstChildOfClass("Highlight"):Destroy()
            end
        end
         
        local function predictPosition(target)
            if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
                local velocity = target.Character.HumanoidRootPart.Velocity
                local position = target.Character[lockPart].Position
                local predictedPosition = position + (velocity * predictionFactor)
                return predictedPosition
            end
            return nil
        end
         
        local function handleToggle()
            if debounce then return end
            debounce = true
            toggleState = not toggleState
            wait(0.3)  -- Debounce time to prevent multiple toggles
            debounce = false
        end
         
        loop = RunService.RenderStepped:Connect(function()
            if aimbotEnabled then
                updateFOVRing()
         
                local localPlayer = Players.LocalPlayer.Character
                local cam = workspace.CurrentCamera
                local screenCenter = workspace.CurrentCamera.ViewportSize / 2
         
                if Toggle then
                    if UserInputService:IsKeyDown(ToggleKey) then
                        handleToggle()
                    end
                else
                    toggleState = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)
                end
         
                if toggleState then
                    if not currentTarget then
                        currentTarget = getClosest(cam.CFrame)
                        highlightTarget(currentTarget)  -- Highlight the new target if enabled
                    end
         
                    if currentTarget and currentTarget.Character and currentTarget.Character:FindFirstChild(lockPart) then
                        local predictedPosition = predictPosition(currentTarget)
                        if predictedPosition then
                            workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame:Lerp(CFrame.new(cam.CFrame.Position, predictedPosition), smoothing)
                        end
                        FOVring.Color = Color3.fromRGB(0, 255, 0)  -- Change FOV ring color to green when locked onto a target
                    else
                        FOVring.Color = Color3.fromRGB(255, 128, 128)  -- Revert FOV ring color to original when not locked onto a target
                    end
                else
                    if currentTarget and highlightEnabled then
                        removeHighlight(currentTarget)  -- Remove highlight from the old target
                    end
                    currentTarget = nil
                    FOVring.Color = Color3.fromRGB(255, 128, 128)  -- Revert FOV ring color to original when not locked onto a target
                end
            end
        end)
    end,
 })
